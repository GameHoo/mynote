# 并查集

## 思路

1. 维护一个数组，保存各个顶点所属老大（集合里的一个顶点，表示这个集合）。
   初始时，顶点的老大都是自己。
2. 遍历边，如果边的顶点不属于一个集合，让其中一个老大认另外一个老大为老大。
3. 一个点要查询自己属于哪个老大，只需要求它的老大的老大的老大...（直到老大以自己为老大为止）是谁。

用DFS实现：

1. 遍历所有点，对每个点，用DFS一下访问完它所在的集合，这个集合的点被标记，不再访问。

>上面的方法是遍历边，这个方法是遍历点，如果是跟点有关的操作，用这个可能思路更清晰。

## 应用

### 计算集的个数

遍历每个点，标记他们集合的老大。然后统计老大的数量。

### 属于集合的变量

如果要计算和存储属于集合的变量，开个数组，用集合老大的序号表示该集合的位置。

### 对老大的选择有要求

联合的时候增加判断即可

### 计算集合的点个数

## 示例代码

```c++
//带优化的极简并查集
int getRoot(int a)
{
	return P[a] == a ? a : P[a]=getRoot(P[a]);
}
void Union(int a, int b)
{
	P[getRoot(b)] = getRoot(a);
}
bool IsSame(int a, int b)
{
	return getRoot(a) == getRoot(b);
}
```