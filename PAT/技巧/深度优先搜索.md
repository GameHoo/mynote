# 深度优先搜索

```c++
void dfs(int root=0)
{
	if (G[root] == nullptr)//是叶子节点
	{
		if (min_Count > Count)
		{
			min_Count = Count;
			Count_OF_retailer=1;
		}
		else if(min_Count==Count)
		{
			Count_OF_retailer++;
		}
		return;
	}
	for (int i = 0; i < G[root]->size();i++)
	{
		Count++;
		dfs((*G[root])[i]);
		Count--;
	}
}

```

## 应用

### 得到最优路径

需要用stack记录路径

### 计算连通数

## 优化

剪枝，dfs的参数携带限制条件

