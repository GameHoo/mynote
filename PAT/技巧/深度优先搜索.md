# 深度优先搜索

## 思路

​	DFS函数先访问参数里传来的初始节点，接下来递归的调用自身传入初始节点的后继节点作为新的初始节点。

​	DFS的执行顺序是不停的递归自己从**初始节点**到它的**后继**然后是它的**后继的后继**最后没有后继DFS返回到上一层，上一层DFS选择一个新的后继继续调用DFS。

### 小细节

#### 如何防止节点被重复访问？

使用一个bool数组保存节点是否被访问过的讯息。

在DFS函数开头查询该节点是否已访问，如果已经访问过，则直接退出。如果没有访问过，则标记为已访问继续往下执行。

## 应用

### 得到最优路径

给DFS提供一个起点，DFS从起点开始遍历，在遍历时记下节点跳转的路径，最后遍历到没有节点的时候则是一条路径生成完成，把它暂时存储起来。然后DFS会回退选择新的路径。把这路径和原先暂存的路径做比较，留下最优的，最后DFS遍历完所有路径，留下的就是最优的。

如果最优路径唯一：

​	用一个vector<int> 暂存最优路径

如果最优路径不唯一：

​	用vector<<int> >存放所有最优路径

### 计算连通数

遍历所有节点，节点没访问过，连通块个数就加1，然后把它所在的块用DFS遍历出，连根拔起，这一连通块标记为访问过，然后遍历下一节点。

## 优化

剪枝，dfs的参数携带限制条件



## 示例代码

```c++
void dfs(int root=0)
{
	if (G[root] == nullptr)//是叶子节点
	{
		if (min_Count > Count)
		{
			min_Count = Count;
			Count_OF_retailer=1;
		}
		else if(min_Count==Count)
		{
			Count_OF_retailer++;
		}
		return;
	}
	for (int i = 0; i < G[root]->size();i++)
	{
		Count++;
		dfs((*G[root])[i]);
		Count--;
	}
}
```