# 指令格式

## 基本格式

操作码+地址码

### 操作码

指出指令执行什么操作

提供区分地址码组成信息

### 地址码

被操作的数的地址

#### 寄存器的地址

寄存器的地址是ID编码，ID编码的位数取决于寄存器总个数。

### 指令字长

指令字长 由操作码 地址码 地址码个数确定

指令长度等于机器字长的指令称为单字长指令

还有 半字长指令 双字长指令

## 按地址数分类

零地址指令

一地址指令

​	可能有两个操作数（隐含一个）

二地址指令

三地址指令

四地址指令

## 定长操作码

操作码的位数固定

### 优缺点

​	简化硬件设计，识别速度快。

## 拓展操作码

操作码的位数不固定，使得在指令字长有限的情况下，保持比较丰富的指令种类。

>指令字长不变的情况下
>
>拓展操作码中地址码越少，操作码位数越多，可以表示的就越多

### 优缺点

​	增加了指令译码和分析的难度。

### 拓展操作码设计例子

​	设指令字长为16位，设计有零地址到三地址的指令系统。

三地址

​	地址码占12位

​	操作码剩余4位

​		0000-1110 是15个不同的操作码

​		1111 用来表示，该指令不是三地址

二地址

​	地址码占8位

​	操作码占8位

​		高4位 为1111

​		低4位 0000-1110 是15个不同的操作码

​			1111 用来表示，改指令不是二地址

一地址

​	操作码占 12位

​	高8位 为 1111 1111

​	低4位 0000-1110 是15个不同的操作码

​		1111 用来表示，改指令不是二地址

零地址

​	操作码占16位

​	高12位 为 1111 1111 1111

​	低4位 0000-1111 是16个不同的操作码

### 设计拓展操作码

#### 设计原则

​	不允许短码是长码的前缀

​	各指令的操作码不能重复

​	使用频率高的指令，分配较短的操作码

# 指令寻址方式

指令中的地址码并不能代表操作数的真实地址，称为形式地址（A）。用寻址方式可以计算出操作数在存储器中的真实地址，成文有效地址（EA）.

>地址码 可能是 寄存器的编号、内存地址 所以不一定是有效地址
>
>EA=（A）的意思就是有效地址是 A中存放的数值（注意括号的意义，代表从A中取数）

## 采用不同寻址方式的目的

缩短指令字长，扩大寻址空间，提高编程灵活性。

## 指令寻址

​	寻找下一条要执行的指令的地址。

### 顺序寻址

​	程序计数器PC加1，自动形成下一条指令的地址。

### 跳跃寻址

​	通过转移类指令实现。下条指令的地址不是由PC给出，而是由本条指令给出下条指令地址的计算方式。

​	跳跃到的地址分为 绝对地址（直接得到） 和 相对地址（还是通过PC加偏移得出）

## 数据寻址

​	得到操作数的地址

### 寻址特征位

指令格式：操作码+寻址特征+形式地址A

​	数据寻址方式较多，需要寻址特征字段来指出寻址方式。

### 隐含寻址

​	指令隐含的给出地址，比如规定寄存器作为操作数地址。

优缺点

​	缩短了指令字长。

​	需要增加隐含地址的硬件

### 立即寻址

​	地址字段不是操作数地址，而是操作数本身，又称为立即数。

优缺点

​	不访问主存

​	有位数限制

>在定长指令中最快，在变长指令中就没寄存器寻址快了

### 直接寻址

​	地址字段存放的就是真实地址。

优缺点

​	简单，不需要计算地址，指令在执行阶段只需要访问一次主存。

​	地址字段的位数决定了寻址范围，操作数的地址不容易修改。

### 间接寻址

​	地址字段给出的地址是操作数地址的地址。EA=(A)

​	间接寻址，可以是多次间接。

优缺点

​	可扩大寻址范围（一般是寄存器间接寻址的事情）

​	便于编程（间接寻址可以方便的完成子程序返回）

​	缺点是治疗需要多次访存（如何计算多少次？）

#### 间接寻址特征位

​	需要表明是直接寻址还是间接寻址。

### 寄存器寻址

​	地址字段给出的地址是寄存器的编号。

优缺点

​	执行阶段不访问主存，只访问寄存器，占用位数也短。

​	缺点是寄存器个数有限，价格昂贵。

### 寄存器间接寻址

​	地址字段给出的寄存器编号对应的寄存器中，存放的不是操作数，而是操作数地址。

优缺点

​	比一般间接寻址速度快，但指令执行阶段需要访问主存。

### 相对寻址

​	形式地址A是一个位移量。EA=(PC)+A

>注意PC是下一条指令的地址

优缺点

​	操作数的地址不是固定的，便于程序浮动和多道程序设计，广泛用于转移指令。

>程序浮动的意思是，可以装入任何地址，转移指令相对转移，所以程序还能正常运行。

### 基址寻址

​	EA=(BR)+A,BR是基址寄存器

>基址寄存器的内容由操作系确定
>
>程序执行过程中，基址寄存器的内容不变，A可变。
>
>采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。

优缺点

​	可扩大寻址范围，用户不必考虑自己的程序在主存的哪块区域（只用偏移量），有利于多道程序设计，可以用于编制浮动程序。

### 变址寻址

​	EA=(IX)+A

>A是基地址，(iX)是偏移量
>
>执行过程中 (IX) 总是变，A不可变

优缺点

​	扩大寻址范围，适合编址数组循环遍历程序。

### 堆栈寻址

​	堆栈当前被读/写单元的地址由 堆栈指针寄存器sp给出。

​	使用堆栈寻址的指令，大多是隐含的使用了SP。

#### 进栈出栈SP如何变

### 各种寻址方式的访存次数

### 各种寻址方式的寻址范围

​	注意变址寻址基址寻址相对寻址 什么不变 什么变，什么变决定寻址范围。

# CISC和RISC

这里直接看书吧

## CISC

设置更复杂的新指令来实现软件功能的硬化。

### 主要特点

1. 指令复杂，数目多
2. 指令长度不固定，指令格式多，寻址方式多
3. 可以访存的指令不受限制
4. 各种指令使用频率相差大（2-8定律）
5. 各种指令执行时间相差大，大多数指令需要多个时钟周期
6. 控制器大多采用微程序控制
7. 难以优化为高效的程序

## RISC

减少指令种类，简化指令功能，从而提高指令的执行速度。

1. 选取使用频率最高的简单指令，复杂指令功能由简单指令组合来实现
2. 指令长度固定，指令格式种类少，寻址方式少
3. 只有Load/Store 指令访存，其余指令的操作都在寄存器之间进行
4. CPU中寄存器数量多
5. 一定使用指令流水线技术，大部分指令在一个时钟周期内完成
6. 以硬布线控制为主，不用或少用微程序控制
7. 特别重视编译优化，以减少程序执行时间

## CISC和RISC的比较



# 问题

## 设计例子中，如何让二地址指令有12条，一地址指令有63条？

二地址指令 操作码为 1111 xxxx

​	让xxxx为11xx的时候表示三地址指令

​	所以 二地址指令总共有 0000-1011 有12种

一地址指令 

​	操作码为 1111 11xx xxxx

​	全为1的时候表示零地址指令

​	所以有 00 0000 - 11 1110 为63种

>地址数多的指令，可以分自己的位数给地址数低的指令

### 二地址指令每少一条指令，一地址指令多多少种？

二地址少a种，原先一地址有k种。

​	则现在一地址有 ak种	

## 指令系统是计算机软、硬件的界面？

