# 概念

## 进制转换

### 二进制转8进制和16进制

### 十进制转换为任意进制

​	乘基取整法：

1. 小数部分乘以基数，取整数部分。
2. 把上次的乘积拿来再搞一遍，直到乘积为0（或满足精度要求）
3. 从上往下拿，就是小数部分

> 整数可以准确的用二进制表示，但小数是离散的

​	除基数取余法（整数部分）：

1. 先取余数 写在右边
2. 取余数之后除以基数 把商写在下面
3. 对商再重复以上步骤，直到商为0
4. 对结果 从下往上取 就是整数部分

## 真值和机器数

​	真值：计算机外部用正负号表示的实际的数值。

​	机器数：符号数字化，真值在机器中的表示。

## BCD码

​	8421码：

​		加法修正：

​			大于$(1010)_2$的时候需要加6修正
​			$(1010)_2到(1111)_2为无效码$

> ​	机器内是这么算
>
> ​	题目可以先用十进制算了，再转化成BCD

​	余3码：

​		无权码，是8421码加上$(0011)_2$

​	2421码：

​		特点是大于等于5的4位二进制中最高位为1

## 字符和字符串

### 	ASCII码：

​		有7位，用一个字节可以表示（最高位不用，为0）

### 	汉字的表示和编码：

​		输入编码：用于输入

​			区位码和国标码

​		汉字内码：用于内部处理

​		汉字字形码：用于输出

### 	字符串的存放（大端，小端）

​		小端模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

>一个字节一个字节的倒着放。（注：一个字节=2位16进制=8位2进制）

​		大端模式：是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

## 校验码

​	原理：通过增加一些冗余码，来检验或纠错编码。

### 码距：任意两个合法码字之间最少变化的二进制位数

> 两组代码之间不同位的个数
>
> [8421码](http://baike.baidu.com/item/8421%E7%A0%81)码距d=1无查错、纠错能力。 偶校验 1011001和10110110码距d=2（其中有一位不同）。例如00110和00100码距为1，12345和13344码距为2
>
> d个单比特错就可以把一个码字转换成另一个码字，为了检查出d个错(单比特错)，需要使用[海明距离](http://baike.baidu.com/item/%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB)为d+1的编码；为了纠正d个错，需要使用海明距离为2d+1的编码。
>
> 例如对于信息位长度为K，监督码长度为r，则要指示一[位错](http://baike.baidu.com/item/%E4%BD%8D%E9%94%99/8651350)的N(N=K+r)个可能位置，即纠正一位错，则必须满足如下关系：
>
> 2^r-1≥N=K+r

- 码距不小于2的数据校验码开始有检错能力。


- 码距越大，检错纠错能力越强。

### 常用的校验码

#### 	奇偶校验码

​		奇校验码：整个校验码（有效位和信息位）中“1”的个数为奇数

​		偶校验码：整个校验码（有效位和信息位）中“1”的个数为偶数

​		优缺点：只能检错，不能纠错

#### 	海明（汉明）校验码

​		分组多个校验位

​		优缺点：能发现2位错误，纠正一位错误

#### 	循环冗余校验（CRC）码

​		K位信息位后再拼接R位的校验码，整个编码长度为N位

​		优缺点：可以纠正一位或多位错误（与多项式的选取有关）

## 真值的编码方法

### 定点数

#### 原码

小数原码：

​	$[x]_原=\left\{\begin{array}{ccc}x&1>x\ge0\\1-x&0\ge x>-1\end{array}\right.$

整数原码：

​	$[x]_原=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\2^n-x&0\ge x>-2^n\end{array}\right.$

定义：一个位表示符号，其他位表示绝对值


特点：原码做的0有两种表示

​             计算机减法运算要先比较绝对值大小，再判断符号运算不方便。

表示范围：

#### 补码

整数补码：

​	$[x]_补=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\2^{n+1}+x&0\ge x\ge-2^n\end{array}\right.$

​	真值转机器数

​		正数和原码一样，负数$2^{n+1}+x$（减去x的绝对值）

​	机器数转真值	

​		最高位的权重为$-2^{n-1}，其他和原码一样$

小数补码：

​	$[x]_补=\left\{\begin{array}{ccc}x&1>x\ge0\\2+x&0> x\ge-2^n\end{array}\right.$

​	真值转机器数

​		正数和原码一样，负数2+x（二进制10+x）

​	机器数转真值

​		$[x]_补-2$	
​		

#### 反码

正数编码和原码相同，负数是原码取反

定义：$w位最高位的权重为-(2^{w-1}-1)$

小数反码:

​	$[x]_反=\left\{\begin{array}{ccc}x&1>x\ge 0\\(2-2^{-n})+x&0\ge x>-1\end{array}\right.$

整数反码：

​	$[x]_反=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\(2^{n+1}-1)+x&0\ge x>-2^n\end{array}\right.$

#### 移码

补码不好判断大小，移码好判断

​	$[x]_移=2^n+x$

性质：只能表示整数

#### 原码求补码

正数一样，负数**原码**符号位不变，数值部分取反加一就是**补码**。

#### 补码求原码

正数一样，负数**补码**符号位不变，数值部分取反加一就是**原码**。

#### 原码求反码

正数不变，负数，符号位不变数值位取反。

#### 补码求移码

符号位取反

### 定点数的运算

#### 移位运算

算术移位：

​	正数：移位空位以0添上

​	负数：

​		原码：添0

​		补码：左移添0，右移添1

​		反码：添1

逻辑移位：

​	添0

循环移位：

​	带CF（进位标志位）：

​	不带CF：

​		不带进位标志一起移动

​		但是左移CF会拷贝最高位，右移CF会拷贝最低位

#### 加减运算

原码：

​	加法：

​		符号位相同：符号位不变，绝对值相加

​		符号位不同：绝对值大的减去绝对值小的，符号位与绝对值大的相同

​	减法：

​		把减数的符号位取反，进行加法。

补码：

​	加法：

​		两数的补码直接相加。
>$[A+B]_补=[A]_补+[B]_补$

​	减法

​		减数加个负号，再用加法。
>$[A-B]_补=[A]_补+[-B]_补$

​	最后计算结果要取模

#### 乘法运算

原码一位乘法：

​	**通过移位和加法实现。**

​	一个寄存器存放被乘数，一个寄存器存放乘积的高位，一个寄存器存放乘积的低位（开始时是乘数）。加法只用加在高位，移位是高位低位一起移位。

​	假设$[X]_原=X_SX_1X_2......X_n，[Y]_原=Y_SY_1Y_2......Y_n，P=X·Y$

​	符号位：两符号位异或$P_S=X_S\oplus Y_S$

​	绝对值进行数值计算|P|=|X|*|Y|（设有n位）：

1. 初始部分积为0，Yi=1则部分积加|X|,Yi=0则部分积加0，累加结果右移一位得新部分积。

   > 注意是先加再移位啊

2. 重复上一步骤n次，i=n,n-1,...,2,1

   ​

> 小数运算时可能有绝对值大于1的情况（此时不是溢出），部分积和被乘数取双符号位（仅在运算过程中采取双符号位）。

补码一位乘法（Booth算法）：

假设$[X]_补=X_0X_1X_2......X_n，[Y]_补=Y_0Y_1Y_2......Y_n，P=X·Y$

乘数末尾增加一个0（$Y_{n+1}=0$）

1. 初始部分积为0

2. 进行n+1步操作，i=n到0

   前n次操作(i=n到1)根据 $Y_nY_{n+1}判断干啥$然后部分积右移一位

   | $y_n$ | $y_{n+1}$ | 操作                |
   | ----- | --------- | ----------------- |
   | 0     | 0         | 部分积右移一位           |
   | 0     | 1         | 部分积加$[X]_补，右移一位$  |
   | 1     | 0         | 部分积加$[-X]_补，右移一位$ |
   | 1     | 1         | 部分积右移一位           |

   > 移位按照补码移位规则移位

   第n+1次操作(i=0)和原先的操作一样，只是不右移

   > 最后一步是根据符号位进行校正

#### 除法运算

原码除法：

​	被除数X，除数Y

​	符号位：两符号位异或

​	数值位：绝对值相除

1. 第i步：被除数减去除数得到余数（减法变加法$|X|-|Y|=|X|+(-|Y|)=|X|+[-|Y|]_补$）
   余数为正：商的最低位置1
   ​                     商，余数左移一位
   余数为负：商的最低位置0
   ​                     商，余数左移一位，余数加上除数
2. 执行n+1次，当执行完余数为负时，余数加上Y。

  ​

补码除法：

​	符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。

1. 被除数与除数同号：被除数减去除数
   被除数与除数异号：被除数加上除数
2. 余数与除数同号：商最后一位置1，余数左移一位减去除数
   余数与除数异号：商最后一位置0，余数左移一位加上除数
3. 重复第2步n次
4. 最后，对商的精度没有要求，采用“末尾恒置1”

n代表数值位的位数

#### 符号拓展

两个不同位数的数相加，拓展位数小的数，使位数一样大。

正数：前面填0即可。

负数：

​	原码：与正数相同，符号位再设为1。

​	补码：符号位相同，附加位（拓展多出的空位）整数填1，小数填0。

​	反码：符号位相同，附加位（拓展多出的空位）都填1。

#### 溢出

采用一位符号位：

​	加法中（减法也是用加法实现）参加运算的两个数符号相同（符号相同才有可能溢出），运算结果符号变了，就是溢出了。

​	逻辑表达式$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S(V=1,有溢出)$

​	根据进位判断：

​		符号位的进位与最高数位的进位相同，无溢出。不同，有溢出。

​		逻辑表达式$V=C_S\oplus C_1$

采用双位符号位：

​	00：结果为正数，无溢出

​	01：正溢出

​	10：负溢出

​	11：结果为负数，无溢出

​	逻辑表达式$V=S_{S1}\oplus S_{S2}(V=1,有溢出)$

## 浮点数

$浮点数=尾数*基数^{阶数}$

## 强制类型转换

强制转换位不变 ，只是改变了编码方式

长转短会截断，短转长会拓展。



# 应用

## 海明码的应用

在n=4,k=3时，求1010的海明码？

1. 确定海明码的位数

   n（信息位）,k（校验位）要满足$n+k\le2^k-1(若要检测两位错，需要再加一位为k+1位)$

2. 确定校验位的分布

   $校验位P_i要在海明位位号为2^{i-1}的位置上，其余各位为信息位$

   $\begin{array}{ccc}D_4&D_3&D_2&P_3&D_1&P_2&P_1\end{array}$

3. 分组，形成校验关系

   被校验数据位的海明位号等于校验该数据位的个校验位海明位号之和
   $D_1在三号位，由P_2P_1校验$

   $D_2在五号位，由P_3P_1校验$

   ......

4. 校验位取值

   校验位的值为所在组的所有数据位做异或运算（不同为1，相同为0）

   $P_1=D_1\oplus D_2\oplus D_4$

   ......

   > 如果有全校验位
   >
   > ​	其他校验位1的个数为偶数个 全校验位为0
   >
   > ​	其他校验位1的个数为奇数个 全校验位为1 

5. 检错和纠错

   每组的校验位和数据位做异或运算构成k个校验方程

   $S_1=P_1\oplus D_1 \oplus D_2 \oplus D_4$

   ......

   $S_3S_2S_1就是出错位的二进制表示$

## CRC码的应用

$设生成多项式为G(x)=x^3+x^2+1,信息码为101001，求对应的CRC码$

1. 生成多项式最高幂次为3，R=3，

   信息码长度为6，K=6

2. 移位

   将原信息码左移R位，低位补0

   101001000

3. 相除

   对移位后的信息码进行模2除法，产生余数001，余数放在校验位

   101001001

4. 检错和纠错

   接收端收到的CRC码和生成多项式进行模2除法：

   ​	余数为0，无错
   ​	余数为010说明CRC码第二位出错

## 模2运算
​	模2（加/减/乘/除）法：

​		加：不进位的加法
​		减：不借位（0-1=1，1-0=1，0-0=0，1-1=0）
​		乘：与普通乘法一样，但最后相加用模2加法
​		除：与普通除法一样，但最后相减用模2减法，（循环直到余数小于除数）

## 码距和查错、纠错能力的关系？

码距和查错、纠错能力具有以下关系：

若码距为奇数，可发现 d-1 位错误，可纠正 （d-1）/ 2 位错误。

若码距为偶数，可发现 d-1位错误，可纠正 d / 2 - 1 位错误。

码距与其检错、纠错能力的关系：

在任意长码字的情况下，[差错控制](http://baike.baidu.com/item/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/1614020)的最小码距Dmin与其检错、纠错能力

（1）在一个码集中**检测e个错误**，要求最小码距满足：Dmin>=e+1

（2）在一个码集中**纠正t个错误**，要求最小码距满足：Dmin>=2t+1

（3）在一种码集中**纠正t个错误的同时检测e（e>=t）个错误**，要求最小码距满足：

Dmin>=t+e+1

## 大量数据传送，用什么校验码？

CRC

## 码距是什么意思？

## 信息位，校验位是什么意思？

信息位，保存有信息的位

校验位，存放校验标志的位

## CRC码的纠错原理？

选择适当的生成多项式，信息位的长度确定的时候，余数（校验码）与CRC码出错位的对应关系是不变的

因此可以用余数作为判断出错位置的依据而纠正错码

## n位无符号纯小数能表示的最大小数是多少？

每一位都取1

$=2^{-1}+2^{-2}+2^{-3}\cdots+2^{-n}=1-2^{-n}(等比公式)$

## n位无符号整数能表示的最大整数是多少？

每一位都取1

$=2^0+2^1+2^2+2^3+\cdots+2^n=2^n-1$

另一种方法：

​	$总共有2^n个整数是连续的整数，其中有0，则最大的是2^n-1$

## 了解下小数的补码，与整数的运算规则一样吗？

## 强制类型转换有什么规则？

## 乘法运算中部分积和被乘数采用双符号位有什么用？

## 结构体对齐的规则是什么？