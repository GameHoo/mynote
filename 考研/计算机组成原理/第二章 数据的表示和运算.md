# 概念

## 进制转换

### 二进制转8进制和16进制

### 十进制转换为任意进制

​	乘基取整法：

1. 小数部分乘以基数，取整数部分。
2. 把上次的乘积拿来再搞一遍，直到乘积为0（或满足精度要求）
3. 从上往下拿，就是小数部分

> 整数可以准确的用二进制表示，但小数是离散的

​	除基数取余法（整数部分）：

1. 先取余数 写在右边
2. 取余数之后除以基数 把商写在下面
3. 对商再重复以上步骤，直到商为0
4. 对结果 从下往上取 就是整数部分

## BCD码

​	8421码：

​		加法修正：

​			大于$(1010)_2$的时候需要加6修正
​			$(1010)_2到(1111)_2为无效码$

> ​	机器内是这么算
>
> ​	题目可以先用十进制算了，再转化成BCD

​	余3码：

​		无权码，是8421码加上$(0011)_2$

​	2421码：

​		特点是大于等于5的4位二进制中最高位为1

## 字符和字符串

### 	ASCII码：

​		有7位，用一个字节可以表示（最高位不用，为0）

### 	汉字的表示和编码：

​		输入编码：用于输入

​			区位码和国标码

​		汉字内码：用于内部处理

​		汉字字形码：用于输出

### 	字符串的存放（大端，小端）

​		小端模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；

>一个字节一个字节的倒着放。（注：一个字节=2位16进制=8位2进制）

​		大端模式：是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。

## 校验码

​	原理：通过增加一些冗余码，来检验或纠错编码。

### 码距：任意两个合法码字之间最少变化的二进制位数

> 两组代码之间不同位的个数
>
> [8421码](http://baike.baidu.com/item/8421%E7%A0%81)码距d=1无查错、纠错能力。 偶校验 1011001和10110110码距d=2（其中有一位不同）。例如00110和00100码距为1，12345和13344码距为2
>
> d个单比特错就可以把一个码字转换成另一个码字，为了检查出d个错(单比特错)，需要使用[海明距离](http://baike.baidu.com/item/%E6%B5%B7%E6%98%8E%E8%B7%9D%E7%A6%BB)为d+1的编码；为了纠正d个错，需要使用海明距离为2d+1的编码。
>
> 例如对于信息位长度为K，监督码长度为r，则要指示一[位错](http://baike.baidu.com/item/%E4%BD%8D%E9%94%99/8651350)的N(N=K+r)个可能位置，即纠正一位错，则必须满足如下关系：
>
> 2^r-1≥N=K+r

- 码距不小于2的数据校验码开始有检错能力。


- 码距越大，检错纠错能力越强。

### 常用的校验码

#### 	奇偶校验码

​		奇校验码：整个校验码（有效位和信息位）中“1”的个数为奇数

​		偶校验码：整个校验码（有效位和信息位）中“1”的个数为偶数

​		优缺点：只能检错，不能纠错

#### 	海明（汉明）校验码

​		分组多个校验位

​		优缺点：能发现2位错误，纠正一位错误

#### 	循环冗余校验（CRC）码

​		K位信息位后再拼接R位的校验码，整个编码长度为N位

​		优缺点：可以纠正一位或多位错误（与多项式的选取有关）

## 真值和机器数

​	真值：计算机外部用正负号表示的实际的数值。

​	机器数：符号数字化，真值在机器中的表示。

## 定点数的机器数编码

### 原码

小数原码：

​	$[x]_原=\left\{\begin{array}{ccc}x&1>x\ge0\\1-x&0\ge x>-1\end{array}\right.$

整数原码：

​	$[x]_原=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\2^n-x&0\ge x>-2^n\end{array}\right.$

定义：一个位表示符号，其他位表示绝对值


特点：原码做的0有两种表示

​             计算机减法运算要先比较绝对值大小，再判断符号运算不方便。

表示范围：

### 补码

思想：确定了模就可以找到一个正数来代替负数，用它来进行加减运算，与一个数做减法就是与它的补数做加法。

整数补码：

​	$[x]_补=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\2^{n+1}+x&0\ge x\ge-2^n\end{array}\right.$

​	真值转机器数

​		正数和原码一样，负数$2^{n+1}+x$（减去x的绝对值）

​	机器数转真值	

​		最高位的权重为$-2^{n-1}，其他和原码一样$

>补码比原码多表示一个负数
>
>补码的模是2的{机器位数+1}次方

小数补码：

​	$[x]_补=\left\{\begin{array}{ccc}x&1>x\ge0\\2+x&0> x\ge-2^n\end{array}\right.$

​	真值转机器数

​		正数和原码一样，负数2+x（二进制10+x）

​	机器数转真值

​		$[x]_补-2$	

>补码比原码多表示一个-1

​		

### 反码

正数编码和原码相同，负数是原码取反

定义：$w位最高位的权重为-(2^{w-1}-1)$

小数反码:

​	$[x]_反=\left\{\begin{array}{ccc}x&1>x\ge 0\\(2-2^{-n})+x&0\ge x>-1\end{array}\right.$

整数反码：

​	$[x]_反=\left\{\begin{array}{ccc}0,x&2^n>x\ge0\\(2^{n+1}-1)+x&0\ge x>-2^n\end{array}\right.$

### 移码

补码不好判断大小，移码好判断

​	$[x]_移=2^n+x$

性质：只能表示整数

### 原码求补码

正数一样，负数**原码**符号位不变，数值部分取反加一就是**补码**。

### 补码求原码

正数一样，负数**补码**符号位不变，数值部分取反加一就是**原码**。

### 补码直接算出真值

符号位是负权，其他位是正权

### 原码求反码

正数不变，负数，符号位不变数值位取反。

### 补码求移码

符号位取反

## 定点数的运算

### 移位运算

算术移位：

​	符号位不变

​	正数：移位空位以0添上

​	负数：

​		原码：添0

​		补码：左移添0，右移添1

​		反码：添1

>算术移位的含义:相当于C语言里  左移x*2 右移x/2

逻辑移位：

​	添0

循环移位：

​	带CF（进位标志位）：

​	不带CF：

​		不带进位标志一起移动

​		但是左移CF会拷贝最高位，右移CF会拷贝最低位

### 加减运算

原码：

​	加法：

​		符号位相同：符号位不变，绝对值相加

​		符号位不同：绝对值大的减去绝对值小的，符号位与绝对值大的相同

​	减法：

​		被减数和减数的补数相加。$[X-Y]_补=[X]_补+[-Y]_补$

补码：

​	加法：

​		两数的补码直接相加。
>$[A+B]_补=[A]_补+[B]_补$

​	减法

​		减数加个负号，再用加法。
>$[A-B]_补=[A]_补+[-B]_补$

​	最后计算结果要取模

### 乘法运算

原码一位乘法：

​	**通过移位和加法实现。**

​	一个寄存器存放被乘数，一个寄存器存放乘积的高位，一个寄存器存放乘积的低位（开始时是乘数）。加法只用加在高位，移位是高位低位一起移位。

​	假设$[X]_原=X_SX_1X_2......X_n，[Y]_原=Y_SY_1Y_2......Y_n，P=X·Y$

​	符号位：两符号位异或$P_S=X_S\oplus Y_S$

​	绝对值进行数值计算|P|=|X|*|Y|（设有n位）：

​		维护部分积（高位部分积有2位符号位，和n位数值位，低位部分积有n位），算法结束时部分积就是乘积。

1. 初始化：高位部分积为0，低位部分积放入乘数的绝对值(n位)

2. 判断低位部分积的最后一位（乘数的最后一位），=1则高位部分积加|X|,=0则高位部分积加0，最后把整个部分积逻辑右移一位

   > 注意是先加再移位啊

3. 重复上一步骤n次，i=n,n-1,...,2,1，直到乘数被右移挤出去，剩下的就是乘积了。

   ​

> 小数运算时可能有绝对值大于1的情况（此时不是溢出），部分积和被乘数取双符号位（仅在运算过程中采取双符号位）。

补码一位乘法（Booth算法）：

假设$[X]_补=X_0X_1X_2......X_n，[Y]_补=Y_0Y_1Y_2......Y_n，P=X·Y$

维护部分积（高位部分积有2位符号位，和n位数值位，低位部分积有1位符号位，n位数值位），算法结束时部分积就是乘积。

1. 初始化：高位部分积为0，低位部分积为乘数后面加一个0

2. 进行n+1步操作，i=n到0

   前n次操作(i=n到1)根据低位部分积的最后两位判断干啥,然后部分积右移一位

   | $y_n$ | $y_{n+1}$ | 操作                |
   | ----- | --------- | ----------------- |
   | 0     | 0         | 部分积右移一位           |
   | 0     | 1         | 部分积加$[X]_补，右移一位$  |
   | 1     | 0         | 部分积加$[-X]_补，右移一位$ |
   | 1     | 1         | 部分积右移一位           |

   > 移位按照补码移位规则移位

   第n+1次操作(i=0)和原先的操作一样，只是不右移

   > 最后一步是根据符号位进行校正

3. 结束：乘数被完全移出。部分积高位改成单符号位，和低符号位拼接起来就是乘积。

### 除法运算

恢复余数法：不够除（余数小于0），返回上一步（恢复余数到被除之前），被除数左移（前面商为0，用下一位的商看行不行）继续操作。

原码除法（不恢复余数法）：恢复余数法的改进版，r<0则2r+|y|,r>0则2r-|y|。

​	被除数X，除数Y

​	符号位：两符号位异或

​	数值位：绝对值相除

1. 第i步：被除数减去除数得到余数（减法变加法$|X|-|Y|=|X|+(-|Y|)=|X|+[-|Y|]_补$）
   余数为正：商的最低位置1
   ​                     商，余数左移一位，余数减去除数
   余数为负：商的最低位置0
   ​                     商，余数左移一位，余数加上除数
2. 执行n+1次，当执行完余数为负时，余数加上Y。

  ​

补码除法（加减交替法）：

​	符号位参加运算，除数与被除数均用补码表示，商和余数也用补码表示。

1. 被除数与除数同号：被除数减去除数
   被除数与除数异号：被除数加上除数
   得余数
2. 余数与除数同号（被除数不够减）：商最后一位置1，余数左移一位减去除数
   余数与除数异号（被除数够减）：商最后一位置0，余数左移一位加上除数
3. 重复第2步n次
4. 最后，对商的精度没有要求，采用“末尾恒置1”

n代表数值位的位数

### 符号拓展

两个不同位数的数相加，拓展位数小的数，使位数一样大。

正数：前面填0即可。

负数：

​	原码：与正数相同，符号位再设为1。

​	补码：符号位相同，附加位（拓展多出的空位）整数填1，小数填0。

​	反码：符号位相同，附加位（拓展多出的空位）都填1。

### 溢出判断

采用一位符号位：

​	加法中（减法也是用加法实现）参加运算的两个数符号相同（符号相同才有可能溢出），运算结果符号变了，就是溢出了。

​	逻辑表达式$V=A_SB_S\overline{S_S}+\overline{A_SB_S}S_S(V=1,有溢出)$

​	根据进位判断：

​		符号位的进位与最高数位的进位相同，无溢出。不同，有溢出。

​		逻辑表达式$V=C_S\oplus C_1$

采用双位符号位：

​	00：结果为正数，无溢出

​	01：正溢出

​	10：负溢出

​	11：结果为负数，无溢出

​	逻辑表达式$V=S_{S1}\oplus S_{S2}(V=1,有溢出)$

采用进位判断溢出：

​	最高有效位进位和符号位进位不同时产生的时候，就是溢出。

## 浮点数的机器数编码

$浮点数真值=尾数*基数^{阶数}$

浮点数的表示格式：阶符|阶码|数符|数码

### 浮点数的规格化

为什么要规格化：充分利用尾数的有效数位，提高精确度。

#### 左规

尾数算术左移，阶码减1

#### 右规

尾数出现溢出时，尾数算术右移，阶码加1

#### 判断是否规格化

规格化之后的尾数要满足：$1/r\le |M|\le 1$

基数为2时，尾数的最高位一定是1.
基数为4时，尾数的最高2位一定有1。
基数是8时尾数的最高3位一定有1.

### 浮点数的上溢和下溢

上溢是阶数不够
下溢是尾数不够

### 浮点数的IEEE 754标准

短浮点数（float）：数符1，阶码8，尾数23

长浮点数（double）：数符1，阶码11，尾数52

临时浮点数：数符1，阶码15，尾数64

#### 阶码用移码表示

三种浮点数阶码偏移量分别为：7FH（127）、3FFH（1023）、3FFFH（16383）

#### 隐藏位

因为float、double尾数最高位总是1，所以这位不需要存在尾数里，把这位隐含。

#### 求真值

float:$(-1)^s\times 1.M\times 2^{E-127}$

double:$(-1)^s\times 1.M\times 2^{E-1023}$

#### 表示范围

正数和负数只是符号差别，只需知道绝对值的表示范围。

以float为例：

最小值：
​	E最小为1（真实值是减去偏移量1-127=-126）
​	M最小为0（有隐藏位，真实值是1.0）
​	所以最小值为:$1.0\times 2^{-126}$

最大值：
​	E最大为254（真实值是减去偏移量254-127=23）
​	M最大为254（有隐藏位，真实值是1.11111111）
​	所以最大值为:$1.11111111\times 2^{127}$

	>0用来表示0了，255用来表示无穷大了

## 浮点数的运算

### 浮点数的加减运算

阶码运算和尾数运算分开。浮点数的加/减运算一律采用补码。

运算步骤：

初始：尾数搞成补码的形式，2位符号位

1. 对阶

   将阶码小的尾数右移、阶码加1，直到两阶码相等

   此过程可能会损失精度

2. 尾数求和

   按定点数的规则

3. 规格化

   尾数大于0时：

   ​	0.1XXXX 是规格化形式

   ​	00.0XXX 需左规

   尾数小于0时：

   ​	11.0XXXX 是规格化形式

   ​	11.1XXXX 需右规

   溢出时：

   ​	10.XXXX 或 01.XXXX 需右规

### 浮点数的舍入

在对阶和右规的过程中，尾数低位丢失可能会损失精度。用舍入法减少损失。

#### 0舍1入

相当于四舍五入，右移时被移去的最高位数值为0，则不管。为1，则移去之后在尾数的末尾加1.

> 可能使尾数又溢出

#### 恒置1法

不管丢掉的数是什么，把剩下的尾数的末尾恒置1

### 浮点数的溢出判断

尾数之和溢出不是真正的溢出，因为这时候还能调节阶码。

阶码溢出是真正的溢出。

上溢：阶码符号位为01，阶码大于最大阶码，中断处理

> 阶码符号开始是00，是正数，加到溢出了

下溢：阶码符号位为10，阶码小于最小阶码，视作0

>阶码符号开始是11,是负数，减到溢出了

## 强制类型转换

强制转换位不变 ，只是改变了编码方式

长转短会截断，短转长会拓展。

char转int：前面补0

int 和 unsigned int: 互相转都可能溢出

int 和 float:

float转换为int 会丢弃小数部分

int 转换为float 因为float的尾数位不够，会舍入。转换成double则不会。



# 应用

## 海明码的应用

在n=4,k=3时，求1010的海明码？

1. 确定海明码的位数

   n（信息位）,k（校验位）要满足$n+k\le2^k-1(若要检测两位错，需要再加一位为k+1位)$

2. 确定校验位的分布

   $校验位P_i要在海明位位号为2^{i-1}的位置上，其余各位为信息位$

   $\begin{array}{ccc}D_4&D_3&D_2&P_3&D_1&P_2&P_1\end{array}$

3. 分组，形成校验关系

   被校验数据位的海明位号等于校验该数据位的个校验位海明位号之和
   $D_1在三号位，由P_2P_1校验$

   $D_2在五号位，由P_3P_1校验$

   ......

4. 校验位取值

   校验位的值为所在组的所有数据位做异或运算（不同为1，相同为0）

   $P_1=D_1\oplus D_2\oplus D_4$

   ......

   > 如果有全校验位
   >
   > ​	其他校验位1的个数为偶数个 全校验位为0
   >
   > ​	其他校验位1的个数为奇数个 全校验位为1 

5. 检错和纠错

   每组的校验位和数据位做异或运算构成k个校验方程

   $S_1=P_1\oplus D_1 \oplus D_2 \oplus D_4$

   ......

   $S_3S_2S_1就是出错位的二进制表示$

## CRC码的应用

$设生成多项式为G(x)=x^3+x^2+1,信息码为101001，求对应的CRC码$

1. 生成多项式最高幂次为3，R=3，

   信息码长度为6，K=6

2. 移位

   将原信息码左移R位，低位补0

   101001000

3. 相除

   对移位后的信息码进行模2除法，产生余数001，余数放在校验位

   101001001

4. 检错和纠错

   接收端收到的CRC码和生成多项式进行模2除法：

   ​	余数为0，无错
   ​	余数为010说明CRC码第二位出错

## 模2运算
​	模2（加/减/乘/除）法：

​		加：不进位的加法
​		减：不借位（0-1=1，1-0=1，0-0=0，1-1=0）
​		乘：与普通乘法一样，但最后相加用模2加法
​		除：与普通除法一样，但最后相减用模2减法，（循环直到余数小于除数）

## 码距和查错、纠错能力的关系？

码距和查错、纠错能力具有以下关系：

若码距为奇数，可发现 d-1 位错误，可纠正 （d-1）/ 2 位错误。

若码距为偶数，可发现 d-1位错误，可纠正 d / 2 - 1 位错误。

码距与其检错、纠错能力的关系：

在任意长码字的情况下，[差错控制](http://baike.baidu.com/item/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/1614020)的最小码距Dmin与其检错、纠错能力

（1）在一个码集中**检测e个错误**，要求最小码距满足：Dmin>=e+1

（2）在一个码集中**纠正t个错误**，要求最小码距满足：Dmin>=2t+1

（3）在一种码集中**纠正t个错误的同时检测e（e>=t）个错误**，要求最小码距满足：

Dmin>=t+e+1

## 大量数据传送，用什么校验码？

CRC

## 码距是什么意思？

## 信息位，校验位是什么意思？

信息位，保存有信息的位

校验位，存放校验标志的位

## CRC码的纠错原理？

选择适当的生成多项式，信息位的长度确定的时候，余数（校验码）与CRC码出错位的对应关系是不变的

因此可以用余数作为判断出错位置的依据而纠正错码

## n位无符号纯小数能表示的最大小数是多少？

每一位都取1

$=2^{-1}+2^{-2}+2^{-3}\cdots+2^{-n}=1-2^{-n}(等比公式)$

## n位无符号整数能表示的最大整数是多少？

每一位都取1

$=2^0+2^1+2^2+2^3+\cdots+2^n=2^n-1$

另一种方法：

​	$总共有2^n个整数是连续的整数，其中有0，则最大的是2^n-1$

## 了解下小数的补码，与整数的运算规则一样吗？

## 强制类型转换有什么规则？

## 乘法运算中部分积和被乘数采用双符号位有什么用？

## 结构体对齐的规则是什么？

取short型时，地址需要是2的倍数，取int型是地址需要是4的倍数，如果不是的话，则可能降低cpu访存的效率

1. **对于结构体的各个成员，第一个成员的偏移量是0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍**
2. **结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍**
3. **如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型**

## 乘除法各操作次数统计

## 为什么加法器可以计算减法

加法器采用的是模$2^n$加法，加法可以直接用，减法可以由被减数加上减数的补数实现

## 十进制分数转化为二进制

11/16=8/16+2/16+1/16

## 加法运算过程中的标志位

溢出标志位：溢出则为1

符号标志位：就是符号位

进位标志位：加法器运算时产生了进位，则为1

>产生进位不代表有溢出

