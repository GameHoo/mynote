# 存储器

## 存储器的属性

### 作用

主存

外存

Cache

### 介质

磁盘、磁带

磁芯存储器

半导体存储器

光存储器

### 存取方式

RAM

ROM

由于flash memory 是从rom发展过来的，所以可以归类为rom

### 串行访问

顺序存取

​	按物理地址的先后顺序

直接

​	先找到某个区域，再顺序

### 信息可保存性

易失性

非易失性

破坏性读出

非破坏性读出

### 性能指标

存储容量

​	存储字数$\times$字长

单位成本

​	总成本/总容量

存储速度

​	数据的宽度/存取周期

其他

​	存取时间

​	存取周期

​		存取时间+复原时间

​	主存带宽

# 存储单元地址分配

按字或者按字节

>字的位数根据机器字长（或数据线根数）来算
>
>字节就是8位

编址

​	按X(B)编址

>最小单位是X(B)

​	寻址范围=存储容量(B)/X

>按什么编址最后 MAR也得是多少位

寻址

​	按字寻址，存储器最小单位是字

> 注意字有几字节跟机器字长有关	

# 多级存储系统

> 注意CPU与内存其实可以直接交换信息，不一定通过Cache

虚拟存储系统

Cache的性能

​	命中

​		命中代表数据在Cache中，可在Cache中存取。

​	有效存取时间

​		有效存取时间=命中率$\times$Cache存取时间+(1-命中率)$\times$主存存取时间

​	效率

​		Cache访问时间/平均访问时间	

# 半导体随机存储器

## 物理结构

1. 存储矩阵

2. 译码驱动

   地址信号翻译成选通信号

3. 读写电路

   包括读出放大器和写出电路

4. 读/写控制线 

5. 片选线  

6. 地址线 

   单向

7. 数据线

   双向

## 74138译码器（3/8译码器）

驿马地址输入端

​	A、B、C

选通端

​	$G_1、\overline{G_{2A}}、\overline{G_{2B}}$

>$G_1高电平\overline{G_{2A}}、\overline{G_{2B}}低电平，译码器才译出$

译码输出端

​	$\overline{Y_0}\sim \overline{Y_7}$

## SRAM存储器和DRAM存储器

### SRAM（静态随机存储器）

​	利用触发器（MOS）来存储信息，不需要再生（非破坏性读出）

​	存取速度快、集成度低、功耗大

### DRAM（动态随机存储器）

​	利用栅极电容上的电荷存储信息，需要刷新再生（刷新周期2ms，以行为单位刷新，题目不给这个条件）

​	容易集成、位价低、容量大、功耗低、存取速度慢、采用地址复用技术

#### 	刷新方式

​		集中刷新

​			一个刷新周期内，利用一段固定的时间全部刷新。

​			优缺点

​				读写操作不受刷新工作影响，存取速度高，但是死时间内不能访问。

​		分散刷新

​			把存储系统的工作周期加上刷新的任务

​			优缺点

​				1.没有死区，死时间，2.加长了系统的存取周期。

​		异步刷新

​			刷新间隔=刷新周期/行数

>行数得看芯片是什么结构
>
>$64\times64结构就是64行$
>
>字、位拓展之后，每个芯片其实还是自己刷新自己的，计算刷新间隔只用考虑一个芯片

​			刷新间隔内刷新一行

​			优缺点

​				1.不会加长存取周期 2.缩短了死时间

​		透明刷新

​			刷新安排在译码阶段，不会加长存取周期

###  存储器的读写周期

​	RAM的读周期

​		给出地址到外部数据总线产生数据的时间。

​		时序图：略

>读周期>读出时间

​	RAM的写周期

## 只读存储器（ROM）

优点

​	结构简单，位密度高

​	非易失性，可靠度高

### ROM的类型

​	掩膜式只读（MROM）

​		无法改变内容

​	一次可编程只读（PROM）

​	可擦除可编程只读（EPROM）

​	闪存

​	固态硬盘

# 存储器与CPU的连接

## 主存与CPU 

连线:

​	数据总线（连着CPU MDR）

​	读/写控制线（CPU控制主存）

​	地址总线（连着CPU MAR，CPU提供主存地址）



# 主存容量的拓展

单个芯片容量有限，字数或者字长不够

## 位拓展

两片芯片地址，片选端，读写控制端并联（公有信息）

一片芯片数据端连接数据总线高位，一片芯片数据端连接数据总线低位。

## 字拓展

两个芯片所有端都并联 。

## 字、位拓展

几个芯片一组，位拓展

加几组芯片，字拓展

>字拓展，地址线增加了，CPU的高位地址线负责片选

## 地址分配和片选

### 字选

CPU的低位地址线完成，低位地址线与所有存储芯片的地址线相连。

### 片选

高位地址线完成片选

#### 线选法

高位地址线直接（或反相器反相）分别连接至各个存储芯片的片选端（$\overline{CS}$）,为“0”就被选了，所以只能有一个为“0”。

优缺点：

​	线路简单，地址空间不连续（1，2，4，8，16......）。

#### 译码片选法

有几片就需要几个片选信号，加上译码器3位就可以译码为8位的片选信号。

## 芯片的选取和连接

1. 根据数据线算出字长，根据地址算出字数。

2. 选择芯片

3. 算出片内地址，然后根据几片算出高位地址（作为片选信号）

   >如果各个片的字数不一样
   >
   >字数高的
   >
   >​	经过1号译码器片选
   >
   >字数低的
   >
   >​	片数只有一片 就设计几个逻辑门（与不属于片内地址，也不属于片选信号地址的地址）共同协助生成片选信号
   >
   >​	片数多	则经过2号译码器

# 存储器存取速度的提升

## 双端口RAM

存储器有两个端口，两组线，可以异步的被使用。

访问冲突

​	同时 同一地址 写入 会发生写入错误

​	同时 同一地址 一写一读 会发生读出错误

解决访问冲突

​	BUSY#信号

​		0时 由判断逻辑暂时关闭一个端口

## 多模块存储器

### 单体多字

​	一个存取周期取出连续的多个字

​	优缺点：连续存取速度快，但是必须是连续的。

### 多体并行

​	多个存储体独立工作

​	优缺点：不同的请求源可以请求不同的存储体。

#### 高位交叉编址（顺序存储）

​	高位作为选择存储体的信号，低位是体内地址。

​	优缺点：有利于存储器的扩充。

#### 低位交叉编址（交叉存储）

​	低位作为选择存储体的信号，高位是体内地址。

​	优缺点：连续读取速度快，大大增加了储存器的带宽。

​	可能的访存冲突

​		如果相邻的访问序列中（体数个相邻），储存体体号相同。

>一个存储体的周期还没结束

### ​带宽计算

​		**一个存储体的过程**

​		CPU先发送个工作命令耗时t（总线周期），从发送命令之前到存储器完成	      				任务是一个存取周期。

​		**交叉存储的连续存取过程**

​			CPU连续发送n个工作命令给n个存储体，n个存储体在各自的存取周期内完成任务

​			用时=一个存取周期+(n-1)个总线周期

>前n-1个发送工作命令用时(n-1)*总线周期
>
>最后一个从发送命令到存取完成 1个存取周期

​		**带宽=存取字/用时**

或者        **带宽=字长/总线周期**

>题目没给要连续读取多少字节这样算

### 根据总线周期和存取周期计算需要多少存储体

​		要保证每次一个总线周期过去有没有工作的存储体

​		存储体个数$\ge$存取周期$\div$总线周期

### 交叉编址根据存储体个数计算读取连续字符需要的时间

1. 设存储器存取周期为T
2. 有4个存储体（$M_1,M_2,M_3,M_4$）则 T/4 的时间（总线周期）读取一个字符
3. 如果读取6个字符，需要6*T/4=3T/2的时间发送工作命令($M_1,M_2,M_3,M_4,M_1,M_2$)
4. 如果再要马上继续读取6个字符，要继续从$M_1$开始发送工作命令，这时$M_1$还有T/2的时间需要等待。
5. 最后一轮的结束时间是本轮$M_2$工作完成
6. 总共时间是(轮数-1)*(每轮发完命令需要时间+命令发完$M_1$准备好的时间)+最后一轮结束需要的时间

>命令发完$M_1$准备好的时间=存取周期-（1+中间发的命令数）*总线周期
>
>为什么有个1，因为第一个命令开始时$M_1$的工作周期就开始了

### 交叉编址一个存储周期能向CPU提供多少位

​	体数*字长

>为什么不算总线周期呢？

# Cache

数据分布的离散型较大，光凭多模块不行。

## 利用局部性原理

空间局部

时间局部

## Cache工作原理

### CPU访问一般过程

​		要访问地址 在Cache中 转化为Cache地址访问Cache

​		要访问地址不 在Cache中 把要访问的地址所在块调入Cache

>Cache与CPU数据交换以块为单位，主存的块编号是主存地址的高位
>
>Cache的一块就是它的一行

### 命中率

​	CPU欲访问的信息在Cache中的比率（次数的比率）

​	平均访问时间

​		次数比率乘以周期

## Cache和主存的地址映射方式

直接映射是先找到Cache再比较标记位，全相联映射是在全部的Cache块中搜索标志位满足的快。

### 标志位

​	记录Cache中的块与主存中哪个块对应，每一个Cache快都有标志位。

​	还应该有个有效位，为1时表明映射有效。	

### 块地址、块内地址

​	主存块地址是高位地址，块内地址是低位地址。Cache块内地址和主存块内地址是相同的。

### 直接映射

​	一个Cache快对应多个主存块

​	Cache块地址=主存块号 mod Cache块数

#### 地址结构

​	主存字块标记+Cache字块地址+字块内地址

>该标记对应 主存的块号

#### 映射过程

​	先根据Cache字块地址找到对应的Cache块，然后比较地址和Cache块的主存字块标记是否相符，还要有效位是否为1。

​	若符合，则可以用。

​	若不符合，则从主存调入Cache。

#### 优缺点

​		实现简单，不灵活只能固定的对应，如果几个对应相同Cache的主存块重	复交替被访问，则要不停的替换，降低了命中率。



### 全相联映射

主存中的字块可以被映射到任意Cache块

#### 地址结构

​	主存字块标记+字块内地址

>该标记对应主存字块地址  和 Cache的字块地址

#### 映射过程

​	用主存字块标记直接与所有Cache块的标记位对比，直到找到。

#### 优缺点

​	灵活，Cache块的冲突概率低，空间利用率高，命中率高；地址变换速度慢（需要）

​	地址变换速度慢，实现成本高，需采用按内容寻址的相联存储器，硬件昂贵。

### 级相联映射

​	将Cache块分组，组件是直接映射，组内是全相联映射。

#### 地址结构

主存字块标记+组地址+字块内地址

####  映射过程

#### 优缺点

​	两者之间。	

#### 二路组相联

​	把每两行分为一组。组间用直接映射，组内用全相联映射。

## Cache总容量计算

一行容量=存储容量+有效位（1bit）+标记位+一致维护性位+替换算法控制位

>标记位表示着当前和哪个主存块映射

总容量=一行容量*行数

### 标记位长度计算

标记位长度=主存地址空间位数-块内地址位数-Cache行号位数

## Cache中主存块的替换算法

采用全相联和组相联映射时

Cache的替换有很大的灵活性

当主存传送过来一个新块，Cache快被占满时，需要选择一个旧块用新的替换。

怎么选择就是替换算法

### 随机算法

实现简单，没有依据局部性原理，可能命中率较低。

### 先进先出算法

比较容易实现，也没有依据局部性原理，可能会吧需要经常使用的快替换掉。（比如循环程序）

### 近期最少用算法

依据了局部性原理，平均命中率比FIFO高，是堆栈类算法。

### 最不经常使用算法

采用计数器，每次替换计数最小的。

## Cache写策略

Cache中的内容只能读取，写入的时候就需要使用写策略，使Cache的数据和主存保持一致。

### 全写法（写直通法）

写命中时，必须把数据同时写入Cache和主存。

快被替换掉时不用操作

#### 优缺点

实现简单，能保证正确性，增加了访存次数，降低了效率。

### 写回法

写命中时，只修改Cache，Cache每行设一个标志位（脏位），被修改了就置1.

快被替换时写入

#### 优缺点

减少了访存次数，存在不一致的隐患。

### 写不命中时

#### 非写分配法

只写入主存，不进行调块进Cache

>通常与全写法合用

#### 写分配法

写入主存，调块进Cache

## 现代CPU多级Cache的策略

按离CPU远近命名为 L1 Cache,L2 Cache,L3 Cache

>L1最近

L1对L2使用全写法，L2对主存使用写回法





# 其他

## 相联存储器

​	把数据搞成表格的形式，按内容（索引）寻址。

## 要加强存储器的带宽怎么加

​	芯片更强，总线宽度增加

## MAR的位数

​	首先至少满足主存地址空间（根据地址线根数算的）

## 存储容量=字长$\times$字数

## 程序局部性原理

程序运行最可能操作连续的内存

## 秒的单位

1s=10^3ms(毫秒)=10^6μs(微秒)=10^9ns(纳秒)

## 地址映射与地址转换

映射是创造规则，转换是执行规则