# 树

n个结点的树有n-1条边

>除第一层根节点外
>
>其他层有几个结点就有几条边

祖先结点：去往跟的路上碰到的结点

子孙结点：相对于祖先结点

双亲结点：父节点

孩子结点：子节点

兄弟结点：相同的双亲结点

结点的度：子节点个数

树的度：树中结点的最大度数

分支结点：度大于0

叶子结点：度为0

结点的层次：

结点的深度：从上往下，逐层累加

结点的高度：从下往上，逐层累加

树的高度：最大层数

有序树和无序数：孩子有顺序

路径：经过结点构成

路径长度：经过边的个数

森林：互不相交的几个树

# 树的性质

1. 结点数等于所有结点的度数（就是边数）+1

2. 度为m的树中第i层上至多有$m^{(i-1)}$个结点

3. 高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点


   >每一层的加起来

4. 具有n个结点的m叉树的最小高度为$\lceil \log_m(n(m-1)+1)\rceil$

## 结点数n求完全树的层数

设有h层

则 前h-1层结点数<n<=前h层结点数

# 二叉树

是有序树

看书

## 满二叉树

有$2^h-1$个结点

## 完全二叉树

## 二叉排序树

## 平衡二叉树

# 二叉树的存储

## 顺序存储

## 链式存储

### 空链域计算

有n个结点，有2n个链域

有n-1条边，用了n-1个，还剩n+1个

# 二叉树的遍历和线索二叉树

## 中序遍历的非递归算法

1. P存放根节点
2. 从根节点压入栈，往左边走，全压入栈
3. 栈中取出，访问，有右孩子则压入
4. 重复第3步，直到栈空

## 由遍历序列构造二叉树

# 线索二叉树

按照一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。

若无左子树，左孩子指向前驱节点

若无右子树，右孩子指向后继节点

左标记和右标记，表示当前到底是指向孩子（0）还是指向前后驱（1）

## 线索二叉树的构造

### 中序线索二叉树

递归参数中存 当前结点 和 上次访问结点

如果当前结点p不为空：

1. 递归线索化左子树

   InThread(&p->lchild,&pre)//这里不确定左子树存在不

   >注意这个过程会改变pre
   >
   >意思就是 左子树中访问的最后一个结点
   >
   >可以当作p的pre

2. 当前结点p的左孩子为空，建立前驱线索

3. 如果前驱结点不为空，且右孩子为空，建立后继线索

4. pre=p

5. 递归线索化右子树

   InThread(p->rchild,pre)


# 树、森林

## 双亲表示法

## 孩子表示法

## 孩子兄弟表示法


# 问题

## 二叉树遍历中最开始和最后遍历的点

中序遍历

​	开始点 最左边的左子树中 左孩子->根节点->右孩子(可以没)

​	结束点 最右边的右子树中......

先序遍历

​	开始点 根节点

​	结束点 最右边的右子树的 根节点->左孩子->右孩子（这个可以没）

后续遍历

​	开始点 最右边的右子树中......

​	结束点 根节点

## 满二叉树和完全二叉树的编号问题

编号从0开始

​	左儿子 2i+1

​	右儿子 2i+2

​	父亲 (n-1)/2

>求父节点个数？

编号从1开始

​	左儿子2i

​	右儿子2i+1

​	父亲n/2

## 完全m叉树的孩子和双亲

### 结点i的第1个子女编号

结点i之前有(i-1)个父结点，他们的孩子个数(i-1)*m再加上一个根结点就是前面的结点的个数，再加1就是结点i的第一个子女的编号

所以是

​	(i-1)*m+2

### 结点i的双亲结点的编号

​	设j是它的双亲

​	i=(j-1)*m+2

​	$\lfloor(i-2)/m\rfloor+1$=j

## n个结点的完全二叉树高度，叶子结点

假设高度为h

$2^{(h-1)}-1<n\le 2^h-1$

$h-1<lg(n+1)\le h$

所以lg(n+1)向上取整就行

>另有$\lfloor lgn\rfloor+1$也行

父结点个数是$\lfloor n/2\rfloor$

## 先序序列为a,b,c,d的不同二叉树的个数

先序序列相当于进栈顺序

中序相当于出栈顺序

>因为中序是先按照先序走了，但是没