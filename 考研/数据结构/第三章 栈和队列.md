# 栈(Stack)

栈是一种线性表

栈顶（Top）：允许插入和删除的一端

栈底（Bottom）：固定的，不允许插入和删除的一端

空栈：不含任何元素的栈

## 顺序栈

### 共享栈

一头一个

## 栈的链式

采用单链表

有个指向head的指针

# 队列（Queue）

Front：指向队头（初始为0）

Rear：指向队尾的下一个位置（初始为0）

>如果rear直接指向队尾，则没有队空的情况了
>
>还可以用front指向队头的前一个位置 rear指向队尾

EnQueue：入队

DeQueue：出队

初始：Q.front==Q.rear==0

队空条件：不好判断

队满条件：不好判断

## 循环队列

使用取余实现，避免非循环的假溢出

初始：Q.front=Q.rear=0

front：指向队头元素

rear：指向队尾元素的前一个

出队/队首指针进1:Q.front=(Q.front+1)%MaxSize

入队/队尾指针进1:Q.rear=(Q.rear+1)%MaxSize

队列长度:(Q.rear+MaxSize-Q.front)%MaxSize

### 区分队满队空

1. 牺牲一个单元来区分队空和队满

   队空条件：Q.front=Q.rear

   队满条件：(Q.rear+1)%MaxSize=Q.front（队头指针在队尾指针的下一个位置）

   >入队时要判别队满

   队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize

   >牺牲的单元不是恒定的
   >
   >反正队满了就不能入队了，剩下一个没有存东西的就是牺牲的

2. 增加表示元素个数的数据成员

3. 增加tag成员

   如果因为删除导致Q.front==Q.rear则队空

   如果因为入队导致Q.front==Q.rear则队满

## 队列的链式

队头指针

队尾指针

头结点：使出队方便

判断是否为空：Q.front==Q.rear

## 双端队列

前端和后端

# 栈和队列的应用

## 括号匹配

## 后缀表达式求值

### 根据运算表达式 求后缀表达式

1. 从左向右扫描中缀表达式

2. 判断

   如果是数字：直接输出

   如果是'('：入栈

   如果是')'：栈中一直取出，直到和一个'('消去

   如果是运算符：

   ​	栈顶也是运算符

   ​		优先级比栈顶高 进栈

   ​		优先级比栈顶低或相等 出栈 直到遇到优先级比自己低的或者'('

   >优先级比自己高和相等的，要出来

   ​	栈顶是'('

   ​		直接进栈

3. 如果遍历完了 栈中剩余全部取出

### 根据后缀表达式 用栈 求值

## 层次遍历

# 队列在计算机系统中的应用

# 特殊矩阵的压缩存储

## 对称矩阵

$a_{ij}=a_{ji}$

把矩阵存到一个一维数组b中

### 计算数组b有多大

假设是$n\times n$的矩阵

​	需要存下三角区和主对角线

​	第1排1个，第2排2个......第n排n个

数组大小为$\frac{n(n+1)}{2}$

### 下标怎么映射

#### 下三角区和主对角线的$a_{ij}(i\ge j)$

安装从上往下，从左往右的顺序存。

前面i-1排有$\frac{i(i-1)}{2}$个

第i排在j前面的有j-1个

总共$\frac{i(i-1)}{2}+j-1$

所以$a_{ij}$对应b中为b[i(i-1)/2+j-1];

#### 上三角区的$a_{ij}(i<j)$

因为对称i,j互换就行

b[j(j-1)/2+i-1]

## 三角矩阵

和对称矩阵原理相同，多个位置b[n(n+1)/2]存常数

上三角

​	k=(i-1)(2n-i+2)/2+j-i

	>第i行前面少i个东西
	>
	>第i行有i-j个东西

下三角

​	和对称矩阵一样

## 三对角矩阵

|i-j|>1时，$a_{ij}=0$就是三对角矩阵

按行优先存储

(1,1) (1,2) (2,1) (2,2)(3,2) (3,3) (3,4)......

i,j求k

​	k=2i+j-3

k求i,j

​	i=(k+1)/3+1 向下取整

​	j=k-2i+3

## 稀疏矩阵

把非零的元素按照 (i,j,v) 存在数组里

失去了随机访问特性

# 问题

## 出栈顺序判断

如果先出来的是最后面的，则前面的必须按照顺序出栈。

## n个数进栈，出栈序列数

$\frac{1}{n+1}C_{2n}^n$

> 3个数有5种
>
> 4个数有14种

列举1，2，3，4的

分别写以1开头，以2开头.......以4开头

## 栈不能得到的序列

已经在栈里面的两个，一定只能按照他们的顺序输出

先输出4，说明1、2、3已经在栈里

先输出2，再输出4，说明1，3已经在栈里

## 双端队列的输出序列

### 不能由输入受限得到的是

​	先输出4，代表1,2,3还在里面

​	2被夹在中间的两边都不能马上输出: 4,2,3,1 4,2,1,3

### 不能由输出受限的双端队列得到的是

​	先输出4，代表1,2,3还在里面

​	1先进来的,2,3按顺序进,不可能在1的左侧有23右侧有32：4,1,3,2 4,2,3,1

>1. 就是和1的绝对距离，安装输入顺序来

### 能由输入受限的双端队列得到，不能由输出受限的双端队列得到的是

1. 先得出不能由输出受限的双端队列得到的

   先得出，不能由一端输入输出得到的

   在上一步中，找不能由两个都输入，一个输出得到的

2. 在第一个的结果中，找能由输入受限的双端队列得到的

实在不行记住结果（P76）

## 队列中rear和 front的指向

### 非循环队列

1. rear指向队尾，front指向队首

   队空不好判断

2. rear指向队尾的下一个,front指向队首

   用rear==front来判空

### 循环队列

1. rear指向队尾，front指向队首

   记录元素个数吧

2. rear指向队尾的下一个,front指向队首

   用rear==front来判空

   判满则牺牲一个单元

   >rear增加时只能增加到n-1个元素(在入队时加入此限制)
   >
   >满的时候 (rear+1)%n=front
   >
   >空的时候就是 rear==front
   >
   >​
   >
   >总而言之
   >
   >​	rear往前只能到front的前一个(满)
   >
   >​	rear往后能到front（空）