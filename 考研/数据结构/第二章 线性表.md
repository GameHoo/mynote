# 线性表

## 顺序表示（SqList）

### 算法

>空间不够的情况：判断maxSize

#### reverse

前半部分和后半部分一对一对交换，交换length/2次

#### 删除为x的元素

不为x的单独计数编号

#### 删除值在s,t之间的数

不在s,t之间的单独计数编号

#### 有序表中删除值重复的元素

#### 两个有序表合并为新的有序表

方法一：两个数组都加入哨兵

方法二：先判断两个都没有用完的情况，再判断其中一个没有用完的情况。

#### 有序表中，两部分交换

reverse,再分别对每个部分reverse

#### 二分查找

```c++
在 范围a[left]到a[right]中寻找key
	
	while (left <= right)
	{
		mid = (left + right) / 2;
		if (a[mid]<key)
		{
			left = mid + 1;
          //丢弃左边
		}
		else if (a[mid]>key)
		{
			right = mid - 1;
          //丢弃右边
		}
		else
		{
			return mid;
		}
	}
```

#### 循环移位

##### 辅助数组

方法一：把要左移的前p个数字放到辅助数组，然后原来的数组左移，后面加上辅助数组中的数。

时间复杂度O(n)、空间复杂度O(1)

方法二：看成两部分交换，先整体reverse,再分别reverse

#### 两个升序序列，求两个序列的中位数

分别求出两个序列的中位数

​	中位数相等，则这个中位数是两个序列的中位数

​	中位数不等，舍弃中位数小的左边，舍弃中位数大的右边

>

​	然后继续,直到两个序列都只有一个数，返回较小的数

#### 求众数

先用抵消法确定一个候选的数

再判断这个数是不是众数

## 链式表示（LinkList）

### 单链表

头指针：表示一个单链表

头结点：第一个不存元素的结点，可以要可以不要，可以存链表信息，也可以不存信息。

带头结点判空条件：头结点的后继指向空指针

头插法：新的数据总是在头部插入

尾插法：新的数据在尾部插入，需要有个尾指针改善时间复杂度

### 双链表

有前驱 prior 后继 next

### 循环单链表

判断为空：头结点的next等于头指针

尾指针：设尾指针可以迅速找到头，而设头指针不能迅速找到尾

### 循环双链表

判断空表：头结点的prior和next都等于头指针

### 静态链表

使用数组来描述线性表的链式存储结构

next指针：是数组下标

## 算法

### 单链表排序

原地插入排序

换到数组里排序（空间换时间）

### 单链表reverse

头插法

### 利用两个链表A，B生成一个新链表存在A

不必申请个新链表的空间，直接A的头结点指向新的链表

### 寻找两个单链表的公共链表

两个链表开始融合是在各自的结点有相同的next时（后面就一直是公共的了）

长的链表减去多余的，和短的链表同步遍历，直到寻找到next相同的两个结点

### 判断带头结点的双循环链表是否对称

肯定是关于头结点对称

### 循环单链表删除一个结点

需要知道这个结点的头结点

### 双链表中删除一个结点

### 单链表找到倒数第k个结点

p指向第k个，q指向第一个

两个都向后移动，知道p指向最后一个

### 单链表去除重复的处于后面的字符

辅助flag数组记录出现过的字符

单链表只需遍历一遍

# 问题

## 单向循环链表，只有表尾的比只有表头的强

