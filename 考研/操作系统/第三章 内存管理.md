# 程序的装入和链接

## 程序运行的步骤

编译  用户源代码编译成若干个模块

链接 链接程序把模块链接为一个装入模块

 装入 装入程序把装入模块送入内存

## 链接

静态链接

装入时动态链接

运行时动态链接

## 装入

绝对装入 

​	使用绝对地址，用于单道程序

可重定位装入(静态重定位)

​	相对地址，装入时转换为绝对地址，装入后内存空间大小不变

动态运行时装入（动态重定位）

​	运行时转换为绝对地址，需要基址寄存器

# 内存保护

保护操作系统不受其他进程影响，进程之间也不相互影响

## 用寄存器存放内存上下界限

## 用基址寄存器和界地址寄存器	

基址寄存器（重定位寄存器）：加上逻辑地址映射成物理地址

界地址寄存器：存放逻辑地址的最大值

# 覆盖与交换

多道程序环境下扩充内存的两种方法

## 覆盖

内存分为固定区和覆盖区，覆盖区相当于是外存的缓冲器

（常常是一个进程内存放不下的情况）

## 交换

等待状态的进程，占用的内存移到外存

# 内存连续分配方式

## 单一连续分配

分为系统区和用户区，每次只有一个程序运行。

## 固定分区分配

把用户内存成大小固定的区，给不同的程序使用

内部碎片：程序很小，固定的分区太大，浪费了

## 动态分区分配

根据进程装入时的大小分配

外部碎片：因为进程们的不停创建和销毁，进程内存之间有很多用不了的小碎片，需要紧凑一下（相当于磁盘整理程序）

### 动态分配的算法

确定各个可以分配的内存块分哪个给新来的进程

#### 首次适应 

​	顺序查找第一个找到的空闲分区，会在内存前面产生碎片

#### 最佳适应

​	满足条件的最小的，会产生最多的小碎片

#### 最坏适应

​	满足条件的最大的，会没有大的连续内存

#### 邻近适应

​	上次查找结束的位置开始找，会在内存后面产生碎片

# 内存非连续分配方式

## 基本分页存储管理方式

把主存空间划分为大小相等且固定的快。以块为基本单位。

需要页表作为索引。

不会产生外部碎片，最后一个分配的快产生内部碎片。

页（Page）：进程中的块

页框（Page Frame）：内存中的块

块（Block）：外存中的块

### 好处

可以不用连续空间，节约了内存。

### 逻辑地址结构

页号+页内偏移量

### 逻辑地址转化为物理地址

页号找到快号，快号和页内地址拼起来就是物理地址

1. 逻辑地址中算出页号和页内偏移
2. 页号超过页表长度，越界中断
3. 找到页表项对应的内存区域=页表起始地址+页号*页表项长度
4. 取出物理快号，地址为 **块号*页面大小+页内偏移**

有快表时：

1. 页号现在快表中找
2. 找到，直接给你
3. 找不到，还是去页表找，然后对快表进行添加或替换

### 页表

存放块号（没有存放页号）

页表寄存器（PTR）：存放页表的首地址 和 页表长度

页表项的大小：与总页数有关

### 快表

在高速缓冲存储器中

取数据访问内存次数：先访问页表 再访问数据的内存 两次

### 两级页表

使用一级页表的不方便之处：

​	对于进程而言，使用的总内存一般很大，一级页表中用到的页表项很少，页表浪费了内存。

解决：

​	把一级页表再以“固定的页表项数”进行划分，划分为多个一级表。

​	再创造一个二级表，建立需要用的一级表的索引。

#### 逻辑地址结构

一级页号+二级页号+页内偏移

## 基本分段存储管理方式

方便编程、信息保护和共享、动态增长、动态链接

按逻辑上划分段，每个段分配连续空间

### 段表

段表项：段长+段起始地址， 一个段表项对应一个段

段表寄存器：存放段表起始地址和段表长度

段号：方便找到段表项（段表起始地址+段号*段表项长度）

### 逻辑地址结构

段号+位移量

### 逻辑地址转化为物理地址

1. 用段号找到对应的段表项
2. 段表项前几位是段长，后几位是起始地址
3. 起始地址+偏移就是物理地址

## 段页式管理方式

先分段再分页

每个进程有一个段表，每个分段有一个页表

### 逻辑地址结构

段号+页号+页内偏移量

### 段表

段表寄存器：段表起始地址+段表长度

段表项：页表长度+页表起始地址 一个段表项对应一个段的页表

# 虚拟内存管理

传统的内存管理浪费内存，虚拟内存利用局部性原理，内存里面只留常用的。

## 请求分页管理方式

 一部分调入内存，缺页中断请求调入，也可以通过置换将暂时不用的调出。

### 页表项增加：

状态位，访问字段，修改位，外存地址

## 页面置换算法

### 最佳置换

选择最长时间内不被访问的页面（无法实现）

### 先进先出

### 最近最久未使用

需要设置访问字段记录未被访问的时间

### 时钟（最近未用）置换

被访问过的留下

简单算法

​	设置使用位，还有一个指向循环缓冲区的指针

​	某一页被替换时
​		指针指向下一个
​	需要替换一页时
​		指针循环扫描，扫到1，变成0，但不用，继续往下
​		扫到0就用

>转一圈之后，指针指向的一般是最老的页（未被访问）

改进型算法

​	增加一个修改位，搜索时避免使用被修改的，因为置换出去还要修改到外存。

​	扫描 未被访问 未被修改的（0，0）
​		找到 直接用
​		找不到（转了一圈） 找 未被访问 被修改的（0，1）
​			扫描过程中 把 (1,x) 修改成 (0,x)
​			找到了 直接用
​			找不到（转了一圈） 从第一步开始再找一圈	

## 页面分配策略

操作系统决定读取多少页到内存

### 固定分配局部置换

固定数目

### 可变分配全局置换

缺页，从进程外部找空页

### 可变分配局部置换

缺页，从进程内部找空页

如果频繁缺页（缺页率高），从进程外部找

缺页率低，进程内部页数减少

## 调入页面的时机



​		

# 问题

## 两级页表的计算

规定:顶级页表只能有一个页面

页个数（页表项个数）计算：逻辑地址空间能表示的字节数/每个页的大小

页占用的内存：页个数*页表项大小

页表项大小：存储逻辑地址需要的内存大小

## 构造适合的页表结构

计算逻辑地址的组成

页面偏移地址位数：页面大小有关

顶级页表最多可以容纳表项数：页面大小/页表项大小